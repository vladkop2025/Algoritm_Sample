using System;

class HeapSortExample
{
    // пирамидальная сортировка (или HeapSort) - Данный алгоритм использует в себе бинарное сортирующее дерево (использующий структуру данных "двоичная куча")
    //данный алгоритм имеет доказанную оценку худшего случая — O(n log n) и не деградирует
    public static void HeapSort(int[] array)
    {
        int n = array.Length;

        // Построение max-кучи (перегруппируем массив)
        for (int i = n / 2 - 1; i >= 0; i--)
            Heapify(array, n, i);

        // Один за другим извлекаем элементы из кучи
        for (int i = n - 1; i > 0; i--)
        {
            // Перемещаем текущий корень в конец
            Swap(ref array[0], ref array[i]);

            // Вызываем процедуру heapify на уменьшенной куче
            Heapify(array, i, 0);
        }
    }

    // Процедура для преобразования поддерева в двоичную кучу
    private static void Heapify(int[] array, int n, int i)
    {
        int largest = i; // Инициализируем наибольший элемент как корень
        int left = 2 * i + 1; // левый = 2*i + 1
        int right = 2 * i + 2; // правый = 2*i + 2

        // Если левый дочерний элемент больше корня
        if (left < n && array[left] > array[largest])
            largest = left;

        // Если правый дочерний элемент больше, чем самый большой элемент на данный момент
        if (right < n && array[right] > array[largest])
            largest = right;

        // Если самый большой элемент не корень
        if (largest != i)
        {
            Swap(ref array[i], ref array[largest]);

            // Рекурсивно преобразуем в двоичную кучу затронутое поддерево
            Heapify(array, n, largest);
        }
    }

    private static void Swap(ref int a, ref int b)
    {
        int temp = a;
        a = b;
        b = temp;
    }

    static void Main()
    {
        int[] array = { 12, 11, 13, 5, 6, 7 };

        Console.WriteLine("Несортированный массив:");
        Console.WriteLine(string.Join(", ", array));

        HeapSort(array);

        Console.WriteLine("\nОтсортированный массив:");
        Console.WriteLine(string.Join(", ", array));
    }
}

/*
        Ключевые особенности HeapSort

    Сложность алгоритма:

Время работы в худшем, среднем и лучшем случае: O(n log n)
Требует O(1) дополнительной памяти(сортировка на месте)

    Основные шаги:

Построение max-кучи из входного массива
Самый большой элемент находится в корне кучи
Помещаем его в конец массива и уменьшаем кучу
Повторяем процесс, пока в куче не останется один элемент

    Преимущества:

Всегда работает за O(n log n), без худших случаев

Не требует дополнительной памяти (в отличие от MergeSort)
Устойчив к уже отсортированным или обратно отсортированным данным

    Недостатки:

Неустойчивая сортировка(может менять порядок равных элементов)
На практике обычно медленнее, чем QuickSort и MergeSort

        Оптимизации (дополнительно)
Для небольших подмассивов можно использовать сортировку вставками

Можно реализовать min-кучу для сортировки по убыванию
Для работы с пользовательскими типами данных нужно реализовать интерфейс IComparable
HeapSort особенно полезен, когда нужна гарантированная производительность O(n log n) без дополнительных затрат памяти.
*/

/*
Алгоритм IntroSort совмещает в себе несколько алгоритмов: QuickSort, HeapSort и алгоритм сортировки вставками для самых малых данных.
Именно IntroSort используется в методе Sort, который есть у массивов в .Net. Благодаря этому при использовании стандартных методов сортировки 
вы можете быть уверены в том, что сортировка будет наиболее эффективна, и задумываться самому о выборе какого-либо метода не нужно.
*/